'''
https://leetcode.com/problems/minimize-malware-spread/
Idea: BFS through graph, look for biggest component with only 1 malware (because component with > 1 malware cannot be saved, will eventually get infected)
'''
import queue

class Solution:
    
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial_set = set()
        for node in initial:
            initial_set.add(node)
        n = len(graph)
        graph_adj = {}
        for u in range(n):
            graph_adj[u] = []
            for v in range(n):
                if graph[u][v] == 1:
                    graph_adj[u].append(v)
            
        self.max_size = 0
        self.ans = n
        
        self.visited = [False for _ in range(n)] 
        
        for i in range(n):
            if not self.visited[i]:
                self.BFS(graph_adj, i, initial_set)
                
        if self.ans == n:
            return min(initial)
        
        return self.ans
        
        
        
    def BFS(self, graph_adj, i, initial_set):
        q = queue.Queue()
        q.put(i)
        n = len(graph_adj)
        self.visited[i] = True
        num_malware = 0
        component_size = 0
        malware_node = n
        
        while len(q.queue) > 0:
            top = q.get()
            component_size += 1
            if top in initial_set:
                num_malware += 1
                malware_node = min(malware_node, top)
                
            for neighbor in graph_adj[top]:
                if not self.visited[neighbor]:
                    q.put(neighbor)
                    self.visited[neighbor] = True
        
        
        if num_malware == 1 and self.max_size < component_size:
            self.max_size = component_size
            self.ans = malware_node
        elif num_malware == 1 and self.max_size == component_size:
            self.ans = min(self.ans, malware_node)
